<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Echo | Body Music Instrument</title>

    <!-- PWA Meta Tags -->
    <meta name="description" content="Echo - Transform your body into a musical instrument using AI-powered motion tracking">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Echo">

    <!-- Favicon and Icons -->
    <link rel="icon" type="image/svg+xml" href="icon.svg">
    <link rel="apple-touch-icon" href="icon.svg">
    <link rel="manifest" href="manifest.json">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0f;
            overflow: hidden;
            color: #fff;
        }

        #mainCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        #videoContainer {
            position: fixed;
            bottom: 24px;
            right: 24px;
            width: 280px;
            height: 158px;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255,255,255,0.15);
            z-index: 100;
            opacity: 0.85;
            transition: all 0.3s;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }

        #videoContainer:hover {
            opacity: 1;
            transform: scale(1.02);
            border-color: rgba(255,255,255,0.3);
        }

        #webcam {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 24px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            z-index: 50;
        }

        .logo-container {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 6px;
        }

        .logo-icon {
            width: 40px;
            height: 40px;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            background: linear-gradient(135deg, #00d9ff, #00ff88, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.5px;
        }

        .subtitle {
            color: #666;
            font-size: 0.85rem;
            margin-left: 52px;
        }

        .controls {
            position: fixed;
            top: 100px;
            left: 24px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .btn {
            padding: 14px 28px;
            font-size: 0.95rem;
            font-weight: 600;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .btn-start {
            background: linear-gradient(135deg, #00d9ff, #00ff88);
            color: #000;
        }

        .btn-record {
            background: linear-gradient(135deg, #ff6b6b, #ff8e53);
            color: #fff;
        }

        .btn-record.recording {
            background: linear-gradient(135deg, #ff0000, #cc0000);
            animation: pulse 1s infinite;
        }

        .btn-play {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: #fff;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(0, 217, 255, 0.4);
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .status-panel {
            position: fixed;
            top: 100px;
            right: 24px;
            bottom: 210px;
            background: rgba(10,10,15,0.9);
            padding: 20px;
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.08);
            z-index: 100;
            width: 240px;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .status-panel h3 {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 14px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-weight: 600;
        }

        .instrument-status {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .instrument-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .instrument-icon {
            font-size: 1.3rem;
            width: 28px;
        }

        .instrument-name {
            font-size: 0.85rem;
            color: #aaa;
            width: 50px;
        }

        .instrument-bar {
            flex: 1;
            height: 6px;
            background: rgba(255,255,255,0.08);
            border-radius: 3px;
            overflow: hidden;
        }

        .instrument-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.1s;
        }

        .voice-fill { background: linear-gradient(90deg, #ff6b6b, #ffd93d); }
        .strings-fill { background: linear-gradient(90deg, #00d9ff, #9b59b6); }
        .drums-fill { background: linear-gradient(90deg, #00ff88, #ffd93d); }

        .settings-panel {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.08);
            flex: 1;
        }

        .settings-panel h4 {
            font-size: 0.75rem;
            color: #666;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .setting-row {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 14px;
        }

        .setting-row label {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .setting-row select {
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.15);
            background: #1a1a2e;
            color: #fff;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23888' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            padding-right: 30px;
        }

        .setting-row select:hover {
            border-color: rgba(255,255,255,0.3);
            background-color: #252540;
        }

        .setting-row select:focus {
            outline: none;
            border-color: #00d9ff;
            box-shadow: 0 0 0 2px rgba(0, 217, 255, 0.2);
        }

        .setting-row select option {
            background: #1a1a2e;
            color: #fff;
            padding: 10px;
        }

        .setting-row select option:hover {
            background: #00d9ff;
        }

        .help-panel {
            position: fixed;
            bottom: 24px;
            left: 24px;
            background: rgba(10,10,15,0.9);
            padding: 18px;
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.08);
            z-index: 100;
            max-width: 320px;
            font-size: 0.8rem;
            backdrop-filter: blur(10px);
        }

        .help-panel h3 {
            color: #666;
            margin-bottom: 12px;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .help-item {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
            padding: 6px 0;
            border-bottom: 1px solid rgba(255,255,255,0.04);
        }

        .help-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .help-icon {
            font-size: 1.1rem;
            min-width: 28px;
            text-align: center;
        }

        .help-text {
            color: #888;
            font-size: 0.75rem;
        }

        .help-text strong {
            color: #ccc;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a0f;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-screen.hidden {
            display: none;
        }

        .loading-logo {
            width: 80px;
            height: 80px;
            margin-bottom: 24px;
            animation: float 2s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .loader {
            width: 48px;
            height: 48px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top-color: #00d9ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 20px;
            color: #666;
            font-size: 0.85rem;
        }

        .mode-selector {
            display: flex;
            gap: 6px;
            margin-top: 12px;
        }

        .mode-btn {
            padding: 10px 16px;
            font-size: 0.75rem;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            color: #888;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
        }

        .mode-btn:hover {
            background: rgba(255,255,255,0.1);
            color: #fff;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #00d9ff, #00ff88);
            color: #000;
            border-color: transparent;
            font-weight: 600;
        }

        .trigger-flash {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            pointer-events: none;
            z-index: 200;
            opacity: 0;
            transition: opacity 0.1s;
        }

        .trigger-flash.show {
            opacity: 1;
            animation: flashPop 0.3s ease-out;
        }

        @keyframes flashPop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
        }

        .recording-indicator {
            position: fixed;
            top: 24px;
            right: 280px;
            background: rgba(255, 0, 0, 0.9);
            padding: 10px 18px;
            border-radius: 24px;
            display: none;
            align-items: center;
            gap: 10px;
            z-index: 200;
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: 0 4px 20px rgba(255,0,0,0.3);
        }

        .recording-indicator.show {
            display: flex;
        }

        .recording-dot {
            width: 10px;
            height: 10px;
            background: #fff;
            border-radius: 50%;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Scrollbar styling */
        .status-panel::-webkit-scrollbar {
            width: 4px;
        }

        .status-panel::-webkit-scrollbar-track {
            background: transparent;
        }

        .status-panel::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div id="loadingScreen" class="loading-screen">
        <svg class="loading-logo" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <linearGradient id="loadGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#00d9ff"/>
                    <stop offset="50%" style="stop-color:#00ff88"/>
                    <stop offset="100%" style="stop-color:#ff6b6b"/>
                </linearGradient>
            </defs>
            <circle cx="50" cy="50" r="45" stroke="url(#loadGrad)" stroke-width="3" fill="none" opacity="0.3"/>
            <circle cx="50" cy="50" r="35" stroke="url(#loadGrad)" stroke-width="2" fill="none" opacity="0.5"/>
            <circle cx="50" cy="50" r="25" stroke="url(#loadGrad)" stroke-width="2" fill="none" opacity="0.7"/>
            <circle cx="50" cy="50" r="8" fill="url(#loadGrad)"/>
            <path d="M50 20 L50 10 M50 80 L50 90 M20 50 L10 50 M80 50 L90 50" stroke="url(#loadGrad)" stroke-width="2" stroke-linecap="round"/>
        </svg>
        <div class="loader"></div>
        <p class="loading-text">Initializing Echo...</p>
    </div>

    <canvas id="mainCanvas"></canvas>

    <div id="overlay">
        <div class="logo-container">
            <svg class="logo-icon" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <linearGradient id="logoGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#00d9ff"/>
                        <stop offset="50%" style="stop-color:#00ff88"/>
                        <stop offset="100%" style="stop-color:#ff6b6b"/>
                    </linearGradient>
                </defs>
                <circle cx="50" cy="50" r="45" stroke="url(#logoGrad)" stroke-width="3" fill="none" opacity="0.3"/>
                <circle cx="50" cy="50" r="35" stroke="url(#logoGrad)" stroke-width="2" fill="none" opacity="0.5"/>
                <circle cx="50" cy="50" r="25" stroke="url(#logoGrad)" stroke-width="2" fill="none" opacity="0.7"/>
                <circle cx="50" cy="50" r="8" fill="url(#logoGrad)"/>
                <path d="M50 20 L50 10 M50 80 L50 90 M20 50 L10 50 M80 50 L90 50" stroke="url(#logoGrad)" stroke-width="2" stroke-linecap="round"/>
            </svg>
            <h1>Echo</h1>
        </div>
        <p class="subtitle">Your body is the instrument</p>
    </div>

    <div class="controls">
        <button id="startBtn" class="btn btn-start" disabled>
            <span>‚ñ∂</span> Start
        </button>
        <button id="recordBtn" class="btn btn-record" disabled>
            <span>‚óè</span> Record
        </button>
        <button id="playBtn" class="btn btn-play" disabled>
            <span>‚ñ∂</span> Play
        </button>
        <div class="mode-selector">
            <button class="mode-btn active" data-mode="all">All</button>
            <button class="mode-btn" data-mode="voice">Voice</button>
            <button class="mode-btn" data-mode="strings">Strings</button>
            <button class="mode-btn" data-mode="drums">Drums</button>
        </div>
    </div>

    <div class="recording-indicator" id="recordingIndicator">
        <div class="recording-dot"></div>
        <span id="recordingTime">0:00</span>
    </div>

    <div class="status-panel">
        <h3>Live</h3>
        <div class="instrument-status">
            <div class="instrument-row">
                <span class="instrument-icon">üé§</span>
                <span class="instrument-name">Voice</span>
                <div class="instrument-bar">
                    <div id="voiceLevel" class="instrument-fill voice-fill" style="width: 0%"></div>
                </div>
            </div>
            <div class="instrument-row">
                <span class="instrument-icon">üé∏</span>
                <span class="instrument-name">Strings</span>
                <div class="instrument-bar">
                    <div id="stringsLevel" class="instrument-fill strings-fill" style="width: 0%"></div>
                </div>
            </div>
            <div class="instrument-row">
                <span class="instrument-icon">ü•Å</span>
                <span class="instrument-name">Drums</span>
                <div class="instrument-bar">
                    <div id="drumsLevel" class="instrument-fill drums-fill" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <div class="settings-panel">
            <h4>Instruments</h4>
            <div class="setting-row">
                <label>Voice</label>
                <select id="voiceType">
                    <option value="warm">Warm Vocal</option>
                    <option value="choir">Choir Pad</option>
                    <option value="synth">Synth Lead</option>
                    <option value="theremin">Theremin</option>
                </select>
            </div>
            <div class="setting-row">
                <label>Strings</label>
                <select id="stringType">
                    <option value="harp">Harp</option>
                    <option value="guitar">Guitar</option>
                    <option value="piano">Piano</option>
                    <option value="bell">Bell/Chime</option>
                </select>
            </div>
            <div class="setting-row">
                <label>Drums</label>
                <select id="drumKit">
                    <option value="acoustic">Acoustic</option>
                    <option value="electronic">Electronic</option>
                    <option value="percussion">Percussion</option>
                </select>
            </div>
            <div class="setting-row">
                <label>Scale</label>
                <select id="scaleType">
                    <option value="major">C Major</option>
                    <option value="minor">A Minor</option>
                    <option value="pentatonic">Pentatonic</option>
                    <option value="chromatic">Chromatic</option>
                </select>
            </div>
        </div>
    </div>

    <div class="help-panel">
        <h3>How to Play</h3>
        <div class="help-item">
            <span class="help-icon">üòÆ</span>
            <span class="help-text"><strong>Open mouth</strong> to sing (eyebrows = pitch)</span>
        </div>
        <div class="help-item">
            <span class="help-icon">üëå</span>
            <span class="help-text"><strong>Touch thumb</strong> with finger = play note</span>
        </div>
        <div class="help-item">
            <span class="help-icon">üñêÔ∏è</span>
            <span class="help-text"><strong>8 keys</strong>: 4 per hand, <strong>height = pitch</strong></span>
        </div>
        <div class="help-item">
            <span class="help-icon">‚¨áÔ∏è</span>
            <span class="help-text"><strong>Nod down</strong> = kick drum</span>
        </div>
        <div class="help-item">
            <span class="help-icon">‚¨ÜÔ∏è</span>
            <span class="help-text"><strong>Nod up</strong> = snare</span>
        </div>
        <div class="help-item">
            <span class="help-icon">‚ÜîÔ∏è</span>
            <span class="help-text"><strong>Tilt head</strong> = hi-hat / tom</span>
        </div>
    </div>

    <div id="videoContainer">
        <video id="webcam" autoplay playsinline></video>
    </div>

    <div id="triggerFlash" class="trigger-flash"></div>

    <!-- Tone.js for audio synthesis -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

    <!-- MediaPipe -->
    <script type="module">
        import {
            FilesetResolver,
            HandLandmarker,
            FaceLandmarker
        } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.15/vision_bundle.mjs";

        // ==================== CONFIGURATION ====================
        const CONFIG = {
            voice: {
                minFreq: 130.81,  // C3
                maxFreq: 523.25, // C5
                mouthThreshold: 0.18,
            },
            strings: {
                scales: {
                    major: ['C', 'D', 'E', 'F', 'G', 'A', 'B', 'C'],      // 8 notes for 8 fingers
                    minor: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'A'],
                    pentatonic: ['C', 'D', 'E', 'G', 'A', 'C', 'D', 'E'],
                    chromatic: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G']
                },
                // Thumb-touch detection - finger touches thumb to play
                touchThreshold: 0.035,      // Distance threshold for thumb-finger contact (very tight)
                cooldown: 150,              // ms between same finger triggers
                octaveRange: [3, 5],        // Left hand lower, right hand higher
            },
            drums: {
                nodThreshold: 0.025,       // Increased - need more deliberate nods
                tiltThreshold: 0.035,      // Increased - need more deliberate tilts
                cooldown: 180,             // Longer cooldown to prevent accidental triggers
            },
            particles: {
                maxParticles: 1500,
            }
        };

        const NOTE_FREQS = {
            'C': 261.63, 'C#': 277.18, 'D': 293.66, 'D#': 311.13,
            'E': 329.63, 'F': 349.23, 'F#': 369.99, 'G': 392.00,
            'G#': 415.30, 'A': 440.00, 'A#': 466.16, 'B': 493.88
        };

        // ==================== STATE ====================
        const state = {
            isRunning: false,
            mode: 'all',
            voice: { active: false, level: 0 },
            strings: {
                level: 0,
                // Track 8 fingers (4 per hand) - thumb touch detection
                // Each hand: index, middle, ring, pinky touching thumb
                hands: [
                    // Left hand (lower octave)
                    {
                        fingers: [
                            { touching: false, lastTrigger: 0, active: false },
                            { touching: false, lastTrigger: 0, active: false },
                            { touching: false, lastTrigger: 0, active: false },
                            { touching: false, lastTrigger: 0, active: false }
                        ]
                    },
                    // Right hand (higher octave)
                    {
                        fingers: [
                            { touching: false, lastTrigger: 0, active: false },
                            { touching: false, lastTrigger: 0, active: false },
                            { touching: false, lastTrigger: 0, active: false },
                            { touching: false, lastTrigger: 0, active: false }
                        ]
                    }
                ]
            },
            drums: { level: 0, lastTrigger: {}, prevHead: null, smoothedHead: null },
            particles: [],
            isRecording: false,
            isPlaying: false,
            recordedEvents: [],
            recordStartTime: 0,
            playbackTimeout: null,
            currentScale: 'major',
            voiceType: 'warm',
            stringType: 'harp',
            drumKit: 'acoustic'
        };

        // ==================== DOM ELEMENTS ====================
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const video = document.getElementById('webcam');
        const startBtn = document.getElementById('startBtn');
        const recordBtn = document.getElementById('recordBtn');
        const playBtn = document.getElementById('playBtn');
        const loadingScreen = document.getElementById('loadingScreen');
        const triggerFlash = document.getElementById('triggerFlash');
        const voiceLevelEl = document.getElementById('voiceLevel');
        const stringsLevelEl = document.getElementById('stringsLevel');
        const drumsLevelEl = document.getElementById('drumsLevel');
        const recordingIndicator = document.getElementById('recordingIndicator');
        const recordingTimeEl = document.getElementById('recordingTime');

        const voiceTypeSelect = document.getElementById('voiceType');
        const stringTypeSelect = document.getElementById('stringType');
        const drumKitSelect = document.getElementById('drumKit');
        const scaleTypeSelect = document.getElementById('scaleType');

        // ==================== AUDIO ENGINE ====================
        let audioEngine = null;

        function initAudio() {
            const masterGain = new Tone.Gain(0.7).toDestination();
            const reverb = new Tone.Reverb({ decay: 2.5, wet: 0.3 }).connect(masterGain);
            const delay = new Tone.FeedbackDelay({ delayTime: '8n', feedback: 0.15, wet: 0.1 }).connect(reverb);

            const voiceSynths = {
                warm: createVoiceSynth('warm', delay),
                choir: createVoiceSynth('choir', delay),
                synth: createVoiceSynth('synth', delay),
                theremin: createVoiceSynth('theremin', delay)
            };

            const stringSynths = {
                harp: createStringSynth('harp', delay),
                guitar: createStringSynth('guitar', delay),
                piano: createStringSynth('piano', delay),
                bell: createStringSynth('bell', delay)
            };

            const drumKits = {
                acoustic: createDrumKit('acoustic', masterGain, reverb),
                electronic: createDrumKit('electronic', masterGain, reverb),
                percussion: createDrumKit('percussion', masterGain, reverb)
            };

            audioEngine = {
                voiceSynths,
                stringSynths,
                drumKits,
                masterGain,
                voice: {
                    isPlaying: false,
                    currentSynth: null,
                    play(freq, volume, type) {
                        const synth = voiceSynths[type];
                        if (!this.isPlaying || this.currentSynth !== synth) {
                            if (this.isPlaying && this.currentSynth) {
                                this.currentSynth.synth.triggerRelease();
                            }
                            synth.synth.triggerAttack(freq);
                            this.isPlaying = true;
                            this.currentSynth = synth;
                        }
                        synth.synth.frequency.rampTo(freq, 0.1);
                        synth.synth.volume.rampTo(Tone.gainToDb(volume), 0.1);
                    },
                    stop() {
                        if (this.isPlaying && this.currentSynth) {
                            this.currentSynth.synth.triggerRelease();
                            this.isPlaying = false;
                        }
                    }
                },
                strings: {
                    pluck(note, octave, velocity, type) {
                        const synth = stringSynths[type];
                        synth.synth.triggerAttackRelease(note + octave, '4n', undefined, velocity);
                    }
                },
                drums: {
                    trigger(drum, velocity, kit) {
                        const drumKit = drumKits[kit];
                        if (drumKit[drum]) drumKit[drum].trigger(velocity);
                    }
                }
            };

            console.log('Echo audio engine ready');
        }

        function createVoiceSynth(type, output) {
            let synth;
            switch(type) {
                case 'warm':
                    synth = new Tone.MonoSynth({
                        oscillator: { type: 'sawtooth' },
                        filter: { type: 'lowpass', frequency: 1000, Q: 2 },
                        envelope: { attack: 0.1, decay: 0.2, sustain: 0.8, release: 0.5 },
                        filterEnvelope: { attack: 0.1, decay: 0.2, sustain: 0.5, release: 0.5, baseFrequency: 200, octaves: 2 }
                    });
                    break;
                case 'choir':
                    synth = new Tone.MonoSynth({
                        oscillator: { type: 'sine' },
                        filter: { type: 'lowpass', frequency: 800 },
                        envelope: { attack: 0.3, decay: 0.3, sustain: 0.9, release: 0.8 }
                    });
                    break;
                case 'synth':
                    synth = new Tone.MonoSynth({
                        oscillator: { type: 'square' },
                        filter: { type: 'lowpass', frequency: 2000, Q: 5 },
                        envelope: { attack: 0.01, decay: 0.1, sustain: 0.7, release: 0.3 },
                        filterEnvelope: { attack: 0.05, decay: 0.2, sustain: 0.3, release: 0.3, baseFrequency: 500, octaves: 3 }
                    });
                    break;
                case 'theremin':
                    synth = new Tone.MonoSynth({
                        oscillator: { type: 'sine' },
                        envelope: { attack: 0.05, decay: 0.1, sustain: 1, release: 0.5 }
                    });
                    break;
            }
            const vibrato = new Tone.Vibrato({ frequency: 5, depth: 0.1 }).connect(output);
            synth.connect(vibrato);
            return { synth, vibrato };
        }

        function createStringSynth(type, output) {
            let synth;
            switch(type) {
                case 'harp':
                    synth = new Tone.PolySynth(Tone.Synth, {
                        oscillator: { type: 'triangle' },
                        envelope: { attack: 0.005, decay: 0.8, sustain: 0.1, release: 1.5 }
                    });
                    break;
                case 'guitar':
                    synth = new Tone.PolySynth(Tone.Synth, {
                        oscillator: { type: 'sawtooth' },
                        envelope: { attack: 0.002, decay: 0.3, sustain: 0.2, release: 0.8 }
                    });
                    break;
                case 'piano':
                    synth = new Tone.PolySynth(Tone.Synth, {
                        oscillator: { type: 'triangle' },
                        envelope: { attack: 0.001, decay: 1, sustain: 0.3, release: 1 }
                    });
                    break;
                case 'bell':
                    synth = new Tone.PolySynth(Tone.Synth, {
                        oscillator: { type: 'sine' },
                        envelope: { attack: 0.001, decay: 2, sustain: 0, release: 2 }
                    });
                    break;
            }
            const filter = new Tone.Filter({ type: 'lowpass', frequency: 3000 }).connect(output);
            synth.connect(filter);
            return { synth, filter };
        }

        function createDrumKit(type, masterGain, reverb) {
            const kit = {};
            switch(type) {
                case 'acoustic':
                    kit.kick = {
                        synth: new Tone.MembraneSynth({
                            pitchDecay: 0.05, octaves: 6,
                            envelope: { attack: 0.001, decay: 0.4, sustain: 0, release: 0.4 }
                        }).connect(masterGain),
                        trigger(vel) { this.synth.triggerAttackRelease('C1', '8n', undefined, vel); }
                    };
                    kit.snare = {
                        noise: new Tone.NoiseSynth({
                            noise: { type: 'white' },
                            envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.15 }
                        }).connect(masterGain),
                        body: new Tone.MembraneSynth({
                            pitchDecay: 0.01, octaves: 4,
                            envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }
                        }).connect(masterGain),
                        trigger(vel) {
                            this.noise.triggerAttackRelease('8n', undefined, vel * 0.6);
                            this.body.triggerAttackRelease('G3', '16n', undefined, vel);
                        }
                    };
                    kit.hihat = {
                        synth: new Tone.MetalSynth({
                            frequency: 400, envelope: { attack: 0.001, decay: 0.08, sustain: 0, release: 0.08 },
                            harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5
                        }).connect(new Tone.Gain(0.25).connect(masterGain)),
                        trigger(vel) { this.synth.triggerAttackRelease('32n', undefined, vel); }
                    };
                    kit.tom = {
                        synth: new Tone.MembraneSynth({
                            pitchDecay: 0.08, octaves: 4,
                            envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.3 }
                        }).connect(masterGain),
                        trigger(vel) { this.synth.triggerAttackRelease('G2', '8n', undefined, vel); }
                    };
                    break;
                case 'electronic':
                    kit.kick = {
                        synth: new Tone.MembraneSynth({
                            pitchDecay: 0.02, octaves: 8,
                            envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.2 }
                        }).connect(masterGain),
                        trigger(vel) { this.synth.triggerAttackRelease('C1', '8n', undefined, vel); }
                    };
                    kit.snare = {
                        noise: new Tone.NoiseSynth({
                            noise: { type: 'pink' },
                            envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }
                        }).connect(masterGain),
                        trigger(vel) { this.noise.triggerAttackRelease('16n', undefined, vel); }
                    };
                    kit.hihat = {
                        synth: new Tone.NoiseSynth({
                            noise: { type: 'white' },
                            envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.05 }
                        }).connect(new Tone.Gain(0.3).connect(masterGain)),
                        trigger(vel) { this.synth.triggerAttackRelease('32n', undefined, vel); }
                    };
                    kit.tom = {
                        synth: new Tone.Synth({
                            oscillator: { type: 'sine' },
                            envelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.2 }
                        }).connect(masterGain),
                        trigger(vel) { this.synth.triggerAttackRelease('E2', '8n', undefined, vel); }
                    };
                    break;
                case 'percussion':
                    kit.kick = {
                        synth: new Tone.MembraneSynth({
                            pitchDecay: 0.1, octaves: 3,
                            envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.5 }
                        }).connect(reverb),
                        trigger(vel) { this.synth.triggerAttackRelease('D2', '4n', undefined, vel); }
                    };
                    kit.snare = {
                        synth: new Tone.MembraneSynth({
                            pitchDecay: 0.03, octaves: 2,
                            envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.2 }
                        }).connect(reverb),
                        trigger(vel) { this.synth.triggerAttackRelease('A3', '8n', undefined, vel); }
                    };
                    kit.hihat = {
                        synth: new Tone.MetalSynth({
                            frequency: 800, envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.15 },
                            harmonicity: 3, modulationIndex: 20, octaves: 1
                        }).connect(new Tone.Gain(0.2).connect(reverb)),
                        trigger(vel) { this.synth.triggerAttackRelease('16n', undefined, vel); }
                    };
                    kit.tom = {
                        synth: new Tone.MembraneSynth({
                            pitchDecay: 0.15, octaves: 2,
                            envelope: { attack: 0.01, decay: 0.4, sustain: 0, release: 0.4 }
                        }).connect(reverb),
                        trigger(vel) { this.synth.triggerAttackRelease('C3', '4n', undefined, vel); }
                    };
                    break;
            }
            return kit;
        }

        // ==================== MEDIAPIPE SETUP ====================
        let handLandmarker, faceLandmarker;

        async function initMediaPipe() {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.15/wasm"
            );

            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task',
                    delegate: 'GPU'
                },
                runningMode: 'VIDEO',
                numHands: 2,
                minHandDetectionConfidence: 0.7,
                minHandPresenceConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',
                    delegate: 'GPU'
                },
                runningMode: 'VIDEO',
                numFaces: 1,
                outputFaceBlendshapes: true,
                minFaceDetectionConfidence: 0.7,
                minFacePresenceConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            console.log('MediaPipe initialized');
        }

        // ==================== CAMERA SETUP ====================
        async function initCamera() {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: 1280, height: 720, facingMode: 'user', frameRate: { ideal: 30 } }
            });
            video.srcObject = stream;
            await video.play();

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // ==================== PARTICLE SYSTEM ====================
        class Particle {
            constructor(x, y, color, type) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.life = 1;
                this.decay = 0.015 + Math.random() * 0.02;
                this.size = 3 + Math.random() * 5;
                this.color = color;
                this.type = type;

                if (type === 'drums') {
                    this.vx *= 3;
                    this.vy *= 3;
                    this.size *= 2;
                    this.decay *= 2;
                }
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;

                if (this.type === 'voice') {
                    this.vy -= 0.1;
                    this.vx *= 0.98;
                } else if (this.type === 'strings') {
                    this.vy += 0.05;
                    this.vx *= 0.99;
                } else {
                    this.vx *= 0.95;
                    this.vy *= 0.95;
                }
            }

            draw(ctx) {
                const radius = Math.max(0, this.size * this.life);
                if (radius <= 0) return;
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color.replace(')', `, ${Math.max(0, this.life)})`).replace('rgb', 'rgba');
                ctx.fill();
            }
        }

        function emitParticles(x, y, color, type, count = 5) {
            for (let i = 0; i < count; i++) {
                if (state.particles.length < CONFIG.particles.maxParticles) {
                    state.particles.push(new Particle(x, y, color, type));
                }
            }
        }

        // ==================== RECORDING ====================
        let recordingTimeInterval = null;

        function recordEvent(type, data) {
            if (state.isRecording) {
                state.recordedEvents.push({ timestamp: Date.now() - state.recordStartTime, type, data });
            }
        }

        function startRecording() {
            state.recordedEvents = [];
            state.recordStartTime = Date.now();
            state.isRecording = true;
            recordBtn.classList.add('recording');
            recordBtn.innerHTML = '<span>‚ñ†</span> Stop';
            recordingIndicator.classList.add('show');
            // Use setInterval instead of requestAnimationFrame to avoid blocking main loop
            recordingTimeInterval = setInterval(updateRecordingTime, 500);
            updateRecordingTime();
        }

        function stopRecording() {
            state.isRecording = false;
            recordBtn.classList.remove('recording');
            recordBtn.innerHTML = '<span>‚óè</span> Record';
            recordingIndicator.classList.remove('show');
            if (recordingTimeInterval) {
                clearInterval(recordingTimeInterval);
                recordingTimeInterval = null;
            }
            if (state.recordedEvents.length > 0) playBtn.disabled = false;
        }

        function updateRecordingTime() {
            if (!state.isRecording) {
                if (recordingTimeInterval) {
                    clearInterval(recordingTimeInterval);
                    recordingTimeInterval = null;
                }
                return;
            }
            const elapsed = Math.floor((Date.now() - state.recordStartTime) / 1000);
            recordingTimeEl.textContent = `${Math.floor(elapsed / 60)}:${(elapsed % 60).toString().padStart(2, '0')}`;
        }

        function playRecording() {
            if (state.recordedEvents.length === 0 || state.isPlaying) return;
            state.isPlaying = true;
            playBtn.innerHTML = '<span>‚ñ†</span> Stop';

            let eventIndex = 0;
            const startTime = Date.now();

            function playNextEvent() {
                if (!state.isPlaying || eventIndex >= state.recordedEvents.length) {
                    stopPlayback();
                    return;
                }
                const event = state.recordedEvents[eventIndex];
                if (Date.now() - startTime >= event.timestamp) {
                    triggerRecordedEvent(event);
                    eventIndex++;
                }
                state.playbackTimeout = requestAnimationFrame(playNextEvent);
            }
            playNextEvent();
        }

        function stopPlayback() {
            state.isPlaying = false;
            playBtn.innerHTML = '<span>‚ñ∂</span> Play';
            if (state.playbackTimeout) cancelAnimationFrame(state.playbackTimeout);
        }

        function triggerRecordedEvent(event) {
            switch(event.type) {
                case 'voice':
                    audioEngine.voice.play(event.data.freq, event.data.volume, state.voiceType);
                    break;
                case 'voice_stop':
                    audioEngine.voice.stop();
                    break;
                case 'string':
                    audioEngine.strings.pluck(event.data.note, event.data.octave, event.data.velocity, state.stringType);
                    emitParticles(event.data.x, event.data.y, event.data.color, 'strings', 10);
                    break;
                case 'drum':
                    audioEngine.drums.trigger(event.data.drum, event.data.velocity, state.drumKit);
                    emitParticles(canvas.width / 2, canvas.height / 2, event.data.color, 'drums', 15);
                    showTrigger(event.data.emoji);
                    break;
            }
        }

        // ==================== HELPERS ====================
        function getLandmarkPos(landmark) {
            return {
                x: (1 - landmark.x) * canvas.width,
                y: landmark.y * canvas.height,
                z: landmark.z
            };
        }

        function mapRange(value, inMin, inMax, outMin, outMax) {
            return Math.max(outMin, Math.min(outMax, (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin));
        }

        function showTrigger(emoji) {
            triggerFlash.textContent = emoji;
            triggerFlash.classList.add('show');
            setTimeout(() => triggerFlash.classList.remove('show'), 300);
        }

        // Exponential moving average for smoothing
        function smooth(current, target, factor = 0.3) {
            return current + (target - current) * factor;
        }

        // ==================== INSTRUMENT PROCESSORS ====================

        function processVoice(faceLandmarks, blendshapes) {
            if (!faceLandmarks || state.mode === 'strings' || state.mode === 'drums') {
                if (state.voice.active) {
                    audioEngine?.voice.stop();
                    recordEvent('voice_stop', {});
                }
                state.voice.active = false;
                state.voice.level = 0;
                return;
            }

            let mouthOpen = 0;
            let browUp = 0;

            if (blendshapes && blendshapes.length > 0) {
                const shapes = blendshapes[0].categories;
                for (const shape of shapes) {
                    if (shape.categoryName === 'jawOpen') mouthOpen = shape.score;
                    if (shape.categoryName === 'browOuterUpLeft' || shape.categoryName === 'browOuterUpRight') {
                        browUp = Math.max(browUp, shape.score);
                    }
                }
            }

            state.voice.level = mouthOpen;

            if (mouthOpen > CONFIG.voice.mouthThreshold) {
                state.voice.active = true;
                const pitchMod = mapRange(browUp, 0, 0.7, 0, 1);
                const freq = CONFIG.voice.minFreq + (CONFIG.voice.maxFreq - CONFIG.voice.minFreq) * pitchMod;
                const volume = mapRange(mouthOpen, CONFIG.voice.mouthThreshold, 0.7, 0.3, 1);

                audioEngine.voice.play(freq, volume, state.voiceType);
                recordEvent('voice', { freq, volume });

                const pos = getLandmarkPos(faceLandmarks[13]);
                const hue = mapRange(freq, CONFIG.voice.minFreq, CONFIG.voice.maxFreq, 0, 60);
                emitParticles(pos.x, pos.y, `rgb(${255}, ${Math.floor(100 + hue * 2)}, ${50})`, 'voice', Math.floor(volume * 3));
            } else {
                if (state.voice.active) {
                    audioEngine?.voice.stop();
                    recordEvent('voice_stop', {});
                }
                state.voice.active = false;
            }
        }

        // Thumb-touch finger detection - like playing guitar or typing
        // Each finger touching the thumb on the same hand triggers a note
        // 8 total keys: 4 fingers x 2 hands
        function processStrings(handResults) {
            if (state.mode === 'voice' || state.mode === 'drums') {
                state.strings.level = 0;
                return;
            }

            // Track which hands we've seen this frame
            const handsProcessed = [false, false]; // [left, right]

            if (!handResults || handResults.length === 0) {
                state.strings.level = 0;
                // Reset all finger states when no hands detected
                state.strings.hands.forEach(hand => {
                    hand.fingers.forEach(f => {
                        f.touching = false;
                        f.active = false;
                    });
                });
                return;
            }

            const scale = CONFIG.strings.scales[state.currentScale];
            const now = Date.now();

            // Process each detected hand independently
            handResults.forEach((hand) => {
                // Determine if left or right hand based on position in frame
                // In mirrored view: higher X = left side of screen = user's left hand
                const handCenterX = (hand[0].x + hand[5].x + hand[17].x) / 3;
                const handCenterY = (hand[0].y + hand[9].y) / 2;  // Average of wrist and middle finger base
                const isLeftHand = handCenterX > 0.5;
                const stateHandIdx = isLeftHand ? 0 : 1;

                // Mark this hand as processed
                handsProcessed[stateHandIdx] = true;

                const handState = state.strings.hands[stateHandIdx];

                // Base octave based on hand: left = lower, right = higher
                const baseOctave = isLeftHand ? CONFIG.strings.octaveRange[0] : CONFIG.strings.octaveRange[1];

                // Hand height affects octave: higher hand = higher pitch
                // Y ranges from 0 (top) to 1 (bottom), so invert it
                // Map hand Y position to octave modifier: -1 to +1
                const heightMod = Math.round(mapRange(1 - handCenterY, 0.2, 0.8, -1, 1));
                const octave = Math.max(2, Math.min(6, baseOctave + heightMod));

                // Store current octave for display
                handState.currentOctave = octave;

                // Get thumb tip position for THIS hand only
                const thumbTip = hand[4];

                // Finger tips: index(8), middle(12), ring(16), pinky(20)
                const fingerTips = [
                    { idx: 8, name: 'index' },
                    { idx: 12, name: 'middle' },
                    { idx: 16, name: 'ring' },
                    { idx: 20, name: 'pinky' }
                ];

                fingerTips.forEach((finger, fingerIdx) => {
                    const tip = hand[finger.idx];
                    const fingerState = handState.fingers[fingerIdx];

                    // Calculate 3D distance between fingertip and thumb tip (same hand)
                    const dx = tip.x - thumbTip.x;
                    const dy = tip.y - thumbTip.y;
                    const dz = (tip.z || 0) - (thumbTip.z || 0);
                    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

                    const isTouching = distance < CONFIG.strings.touchThreshold;

                    // Trigger on touch (transition from not touching to touching)
                    if (isTouching && !fingerState.touching && (now - fingerState.lastTrigger > CONFIG.strings.cooldown)) {
                        // Note index: left hand = 0-3, right hand = 4-7
                        const noteIdx = (isLeftHand ? 0 : 4) + fingerIdx;
                        const note = scale[noteIdx % scale.length];

                        // Velocity based on how close fingers are (closer = harder press)
                        const velocity = mapRange(distance, CONFIG.strings.touchThreshold, 0.015, 0.6, 1);

                        audioEngine.strings.pluck(note, octave, velocity, state.stringType);

                        // Get midpoint between thumb and finger for particle emission
                        const midX = (tip.x + thumbTip.x) / 2;
                        const midY = (tip.y + thumbTip.y) / 2;
                        const midPos = getLandmarkPos({ x: midX, y: midY, z: 0 });

                        // Colors for each finger
                        const colors = [
                            'rgb(255, 100, 100)',   // index - red
                            'rgb(255, 200, 100)',   // middle - orange
                            'rgb(100, 255, 150)',   // ring - green
                            'rgb(100, 150, 255)'    // pinky - blue
                        ];
                        emitParticles(midPos.x, midPos.y, colors[fingerIdx], 'strings', 15);

                        state.strings.level = 1;
                        fingerState.lastTrigger = now;
                        fingerState.active = true;

                        recordEvent('string', {
                            note, octave, velocity,
                            x: midPos.x, y: midPos.y,
                            color: colors[fingerIdx],
                            hand: isLeftHand ? 'left' : 'right',
                            finger: finger.name
                        });
                    }

                    // Update touching state
                    fingerState.touching = isTouching;

                    // Deactivate when finger separates from thumb
                    if (!isTouching) {
                        fingerState.active = false;
                    }
                });
            });

            // Reset fingers for any hands not detected this frame
            handsProcessed.forEach((processed, handIdx) => {
                if (!processed) {
                    state.strings.hands[handIdx].fingers.forEach(f => {
                        f.touching = false;
                        f.active = false;
                    });
                }
            });

            state.strings.level *= 0.9;
        }

        function processDrums(faceLandmarks, blendshapes) {
            if (state.mode === 'voice' || state.mode === 'strings') {
                state.drums.level = 0;
                return;
            }

            if (!faceLandmarks) {
                state.drums.level = 0;
                state.drums.prevHead = null;
                state.drums.smoothedHead = null;
                state.drums.velocityBuffer = null;
                return;
            }

            const now = Date.now();
            const noseTip = faceLandmarks[1];
            const forehead = faceLandmarks[10];
            const leftCheek = faceLandmarks[234];
            const rightCheek = faceLandmarks[454];

            const headY = (noseTip.y + forehead.y) / 2;
            const headX = (leftCheek.x + rightCheek.x) / 2;
            const headTilt = leftCheek.y - rightCheek.y;

            // Smooth head position with lighter smoothing for more responsiveness
            if (!state.drums.smoothedHead) {
                state.drums.smoothedHead = { y: headY, x: headX, tilt: headTilt };
                state.drums.velocityBuffer = { y: [], tilt: [] };
            } else {
                state.drums.smoothedHead.y = smooth(state.drums.smoothedHead.y, headY, 0.4);
                state.drums.smoothedHead.x = smooth(state.drums.smoothedHead.x, headX, 0.4);
                state.drums.smoothedHead.tilt = smooth(state.drums.smoothedHead.tilt, headTilt, 0.4);
            }

            if (state.drums.prevHead) {
                const velY = state.drums.smoothedHead.y - state.drums.prevHead.y;
                const tiltChange = state.drums.smoothedHead.tilt - state.drums.prevHead.tilt;

                // Buffer velocities for more robust detection (average over last few frames)
                state.drums.velocityBuffer.y.push(velY);
                state.drums.velocityBuffer.tilt.push(tiltChange);
                if (state.drums.velocityBuffer.y.length > 3) state.drums.velocityBuffer.y.shift();
                if (state.drums.velocityBuffer.tilt.length > 3) state.drums.velocityBuffer.tilt.shift();

                const avgVelY = state.drums.velocityBuffer.y.reduce((a, b) => a + b, 0) / state.drums.velocityBuffer.y.length;
                const avgTiltChange = state.drums.velocityBuffer.tilt.reduce((a, b) => a + b, 0) / state.drums.velocityBuffer.tilt.length;

                // NOD DOWN = KICK (requires consistent downward motion)
                if (avgVelY > CONFIG.drums.nodThreshold &&
                    (!state.drums.lastTrigger.kick || now - state.drums.lastTrigger.kick > CONFIG.drums.cooldown)) {
                    const velocity = mapRange(Math.abs(avgVelY), CONFIG.drums.nodThreshold, 0.06, 0.6, 1);
                    audioEngine.drums.trigger('kick', velocity, state.drumKit);
                    emitParticles(canvas.width / 2, canvas.height / 2 + 100, 'rgb(100, 255, 100)', 'drums', 20);
                    showTrigger('‚¨á');
                    state.drums.lastTrigger.kick = now;
                    state.drums.level = 1;
                    state.drums.velocityBuffer.y = []; // Clear buffer after trigger
                    recordEvent('drum', { drum: 'kick', velocity, color: 'rgb(100, 255, 100)', emoji: '‚¨á' });
                }

                // NOD UP = SNARE (requires consistent upward motion)
                else if (avgVelY < -CONFIG.drums.nodThreshold &&
                    (!state.drums.lastTrigger.snare || now - state.drums.lastTrigger.snare > CONFIG.drums.cooldown)) {
                    const velocity = mapRange(Math.abs(avgVelY), CONFIG.drums.nodThreshold, 0.06, 0.6, 1);
                    audioEngine.drums.trigger('snare', velocity, state.drumKit);
                    emitParticles(canvas.width / 2, canvas.height / 2 - 50, 'rgb(255, 255, 150)', 'drums', 20);
                    showTrigger('‚¨Ü');
                    state.drums.lastTrigger.snare = now;
                    state.drums.level = 1;
                    state.drums.velocityBuffer.y = []; // Clear buffer after trigger
                    recordEvent('drum', { drum: 'snare', velocity, color: 'rgb(255, 255, 150)', emoji: '‚¨Ü' });
                }

                // TILT LEFT = HI-HAT (requires consistent tilt)
                if (avgTiltChange > CONFIG.drums.tiltThreshold &&
                    (!state.drums.lastTrigger.hihat || now - state.drums.lastTrigger.hihat > CONFIG.drums.cooldown)) {
                    const velocity = mapRange(Math.abs(avgTiltChange), CONFIG.drums.tiltThreshold, 0.08, 0.5, 0.8);
                    audioEngine.drums.trigger('hihat', velocity, state.drumKit);
                    emitParticles(canvas.width / 2 - 100, canvas.height / 2, 'rgb(255, 255, 200)', 'drums', 10);
                    state.drums.lastTrigger.hihat = now;
                    state.drums.level = 0.7;
                    state.drums.velocityBuffer.tilt = []; // Clear buffer after trigger
                    recordEvent('drum', { drum: 'hihat', velocity, color: 'rgb(255, 255, 200)', emoji: '‚óÄ' });
                }

                // TILT RIGHT = TOM (requires consistent tilt)
                else if (avgTiltChange < -CONFIG.drums.tiltThreshold &&
                    (!state.drums.lastTrigger.tom || now - state.drums.lastTrigger.tom > CONFIG.drums.cooldown)) {
                    const velocity = mapRange(Math.abs(avgTiltChange), CONFIG.drums.tiltThreshold, 0.08, 0.6, 0.9);
                    audioEngine.drums.trigger('tom', velocity, state.drumKit);
                    emitParticles(canvas.width / 2 + 100, canvas.height / 2, 'rgb(150, 255, 100)', 'drums', 15);
                    state.drums.lastTrigger.tom = now;
                    state.drums.level = 0.8;
                    state.drums.velocityBuffer.tilt = []; // Clear buffer after trigger
                    recordEvent('drum', { drum: 'tom', velocity, color: 'rgb(150, 255, 100)', emoji: '‚ñ∂' });
                }
            }

            state.drums.prevHead = { y: state.drums.smoothedHead.y, x: state.drums.smoothedHead.x, tilt: state.drums.smoothedHead.tilt };
            state.drums.level *= 0.9;
        }

        // ==================== VISUAL FEEDBACK ====================
        function drawHands(hands) {
            if (!hands || hands.length === 0) return;

            const scale = CONFIG.strings.scales[state.currentScale];
            const fingerColors = ['#ff6464', '#ffb347', '#64ff8c', '#6496ff'];

            hands.forEach(hand => {
                // Determine which hand (left/right) for state lookup
                const handCenterX = (hand[0].x + hand[5].x + hand[17].x) / 3;
                const handCenterY = (hand[0].y + hand[9].y) / 2;
                const isLeftHand = handCenterX > 0.5;
                const stateHandIdx = isLeftHand ? 0 : 1;
                const handState = state.strings.hands[stateHandIdx];

                // Calculate current octave based on hand height (same logic as processStrings)
                const baseOctave = isLeftHand ? CONFIG.strings.octaveRange[0] : CONFIG.strings.octaveRange[1];
                const heightMod = Math.round(mapRange(1 - handCenterY, 0.2, 0.8, -1, 1));
                const octave = Math.max(2, Math.min(6, baseOctave + heightMod));

                // Draw skeleton connections
                const connections = [
                    [0, 1], [1, 2], [2, 3], [3, 4],
                    [0, 5], [5, 6], [6, 7], [7, 8],
                    [0, 9], [9, 10], [10, 11], [11, 12],
                    [0, 13], [13, 14], [14, 15], [15, 16],
                    [0, 17], [17, 18], [18, 19], [19, 20],
                    [5, 9], [9, 13], [13, 17]
                ];

                ctx.strokeStyle = 'rgba(100, 200, 255, 0.2)';
                ctx.lineWidth = 1;

                connections.forEach(([i, j]) => {
                    const p1 = getLandmarkPos(hand[i]);
                    const p2 = getLandmarkPos(hand[j]);
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                });

                // Draw thumb - simple white circle (collision target)
                const thumbTip = hand[4];
                const thumbPos = getLandmarkPos(thumbTip);

                // Thumb circle - clean white
                ctx.beginPath();
                ctx.arc(thumbPos.x, thumbPos.y, 16, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Finger tips: index(8), middle(12), ring(16), pinky(20)
                const fingerTips = [8, 12, 16, 20];

                fingerTips.forEach((tipIdx, fingerIdx) => {
                    const tip = hand[tipIdx];
                    const pos = getLandmarkPos(tip);
                    const fingerState = handState.fingers[fingerIdx];
                    const isActive = fingerState.active;

                    // Size based on state
                    const baseSize = 14;
                    const size = isActive ? baseSize + 6 : baseSize;

                    // Simple colored circle for fingertip
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
                    ctx.fillStyle = isActive ? '#fff' : fingerColors[fingerIdx];
                    ctx.fill();

                    // Border when active
                    if (isActive) {
                        ctx.strokeStyle = fingerColors[fingerIdx];
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }

                    // Note label
                    const noteIdx = (isLeftHand ? 0 : 4) + fingerIdx;
                    const noteLabel = scale[noteIdx % scale.length];

                    ctx.fillStyle = isActive ? '#000' : '#fff';
                    ctx.font = 'bold 11px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(noteLabel, pos.x, pos.y);
                });

                // Show hand label and octave
                const wrist = getLandmarkPos(hand[0]);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.font = '11px sans-serif';
                ctx.textAlign = 'center';
                const handLabel = isLeftHand ? 'L' : 'R';
                ctx.fillText(`${handLabel}${octave}`, wrist.x, wrist.y + 20);
            });
        }

        function drawFace(face) {
            if (!face || face.length === 0) return;

            const noseTip = getLandmarkPos(face[1]);

            ctx.strokeStyle = 'rgba(255, 200, 100, 0.2)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(noseTip.x, noseTip.y, 40, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.font = '16px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('‚¨Ü', noseTip.x, noseTip.y - 55);
            ctx.fillText('‚¨á', noseTip.x, noseTip.y + 70);
            ctx.fillText('‚óÄ', noseTip.x - 65, noseTip.y + 5);
            ctx.fillText('‚ñ∂', noseTip.x + 65, noseTip.y + 5);
        }

        // ==================== MAIN LOOP ====================
        async function processFrame(timestamp) {
            if (!state.isRunning) return;

            ctx.fillStyle = 'rgba(10, 10, 15, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const handResult = handLandmarker.detectForVideo(video, timestamp);
            const faceResult = faceLandmarker.detectForVideo(video, timestamp);

            processVoice(faceResult.faceLandmarks?.[0], faceResult.faceBlendshapes);
            processStrings(handResult.landmarks);
            processDrums(faceResult.faceLandmarks?.[0], faceResult.faceBlendshapes);

            if (handResult.landmarks) drawHands(handResult.landmarks);
            if (faceResult.faceLandmarks?.[0]) drawFace(faceResult.faceLandmarks[0]);

            state.particles.forEach(p => p.update());
            state.particles = state.particles.filter(p => p.life > 0);
            state.particles.forEach(p => p.draw(ctx));

            voiceLevelEl.style.width = `${state.voice.level * 100}%`;
            stringsLevelEl.style.width = `${state.strings.level * 100}%`;
            drumsLevelEl.style.width = `${state.drums.level * 100}%`;

            requestAnimationFrame(processFrame);
        }

        // ==================== EVENT HANDLERS ====================
        startBtn.addEventListener('click', async () => {
            if (!state.isRunning) {
                await Tone.start();
                state.isRunning = true;
                startBtn.innerHTML = '<span>‚ñ†</span> Stop';
                recordBtn.disabled = false;
                requestAnimationFrame(processFrame);
            } else {
                state.isRunning = false;
                startBtn.innerHTML = '<span>‚ñ∂</span> Start';
                recordBtn.disabled = true;
                audioEngine.voice.stop();
                if (state.isRecording) stopRecording();
                if (state.isPlaying) stopPlayback();
            }
        });

        recordBtn.addEventListener('click', () => {
            if (state.isRecording) stopRecording();
            else startRecording();
        });

        playBtn.addEventListener('click', () => {
            if (state.isPlaying) stopPlayback();
            else playRecording();
        });

        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                state.mode = btn.dataset.mode;
                if (state.mode !== 'all' && state.mode !== 'voice') audioEngine?.voice.stop();
            });
        });

        voiceTypeSelect.addEventListener('change', (e) => { state.voiceType = e.target.value; });
        stringTypeSelect.addEventListener('change', (e) => { state.stringType = e.target.value; });
        drumKitSelect.addEventListener('change', (e) => { state.drumKit = e.target.value; });
        scaleTypeSelect.addEventListener('change', (e) => { state.currentScale = e.target.value; });

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // ==================== INITIALIZATION ====================
        async function init() {
            try {
                await initMediaPipe();
                await initCamera();
                initAudio();

                loadingScreen.classList.add('hidden');
                startBtn.disabled = false;

                console.log('Echo is ready!');
            } catch (error) {
                console.error('Initialization failed:', error);
                loadingScreen.querySelector('.loading-text').textContent =
                    'Failed to initialize. Please allow camera access and refresh.';
            }
        }

        // Register service worker for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').then(() => {
                console.log('Service Worker registered');
            }).catch(err => {
                console.log('Service Worker registration failed:', err);
            });
        }

        init();
    </script>
</body>
</html>
