<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Echo | Body Music Instrument</title>

    <!-- PWA Meta Tags -->
    <meta name="description" content="Echo - Transform your body into a musical instrument using AI-powered motion tracking">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Echo">

    <!-- Favicon and Icons -->
    <link rel="icon" type="image/svg+xml" href="icon.svg">
    <link rel="apple-touch-icon" href="icon.svg">
    <link rel="manifest" href="manifest.json">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0f;
            overflow: hidden;
            color: #fff;
        }

        #mainCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        #videoContainer {
            position: fixed;
            bottom: 24px;
            right: 24px;
            width: 280px;
            height: 158px;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255,255,255,0.15);
            z-index: 100;
            opacity: 0.85;
            transition: all 0.3s;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }

        #videoContainer:hover {
            opacity: 1;
            transform: scale(1.02);
            border-color: rgba(255,255,255,0.3);
        }

        #webcam {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 24px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            z-index: 50;
        }

        .logo-container {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 6px;
        }

        .logo-icon {
            width: 40px;
            height: 40px;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            background: linear-gradient(135deg, #00d9ff, #00ff88, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.5px;
        }

        .subtitle {
            color: #666;
            font-size: 0.85rem;
            margin-left: 52px;
        }

        .controls {
            position: fixed;
            top: 100px;
            left: 24px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .btn {
            padding: 14px 28px;
            font-size: 0.95rem;
            font-weight: 600;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .btn-start {
            background: linear-gradient(135deg, #00d9ff, #00ff88);
            color: #000;
        }

        .btn-record {
            background: linear-gradient(135deg, #ff6b6b, #ff8e53);
            color: #fff;
        }

        .btn-record.recording {
            background: linear-gradient(135deg, #ff0000, #cc0000);
            animation: pulse 1s infinite;
        }

        .btn-play {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: #fff;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(0, 217, 255, 0.4);
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .status-panel {
            position: fixed;
            top: 100px;
            right: 24px;
            bottom: 210px;
            background: rgba(10,10,15,0.9);
            padding: 20px;
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.08);
            z-index: 100;
            width: 240px;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .status-panel h3 {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 14px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-weight: 600;
        }

        .instrument-status {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .instrument-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .instrument-icon {
            font-size: 1.3rem;
            width: 28px;
        }

        .instrument-name {
            font-size: 0.85rem;
            color: #aaa;
            width: 50px;
        }

        .instrument-bar {
            flex: 1;
            height: 6px;
            background: rgba(255,255,255,0.08);
            border-radius: 3px;
            overflow: hidden;
        }

        .instrument-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.1s;
        }

        .voice-fill { background: linear-gradient(90deg, #ff6b6b, #ffd93d); }
        .strings-fill { background: linear-gradient(90deg, #00d9ff, #9b59b6); }
        .drums-fill { background: linear-gradient(90deg, #00ff88, #ffd93d); }

        .settings-panel {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.08);
            flex: 1;
        }

        .settings-panel h4 {
            font-size: 0.75rem;
            color: #666;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .setting-row {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 14px;
        }

        .setting-row label {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .setting-row select {
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.05);
            color: #fff;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .setting-row select:hover {
            border-color: rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.08);
        }

        .setting-row select:focus {
            outline: none;
            border-color: #00d9ff;
        }

        .help-panel {
            position: fixed;
            bottom: 24px;
            left: 24px;
            background: rgba(10,10,15,0.9);
            padding: 18px;
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.08);
            z-index: 100;
            max-width: 320px;
            font-size: 0.8rem;
            backdrop-filter: blur(10px);
        }

        .help-panel h3 {
            color: #666;
            margin-bottom: 12px;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .help-item {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
            padding: 6px 0;
            border-bottom: 1px solid rgba(255,255,255,0.04);
        }

        .help-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .help-icon {
            font-size: 1.1rem;
            min-width: 28px;
            text-align: center;
        }

        .help-text {
            color: #888;
            font-size: 0.75rem;
        }

        .help-text strong {
            color: #ccc;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a0f;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-screen.hidden {
            display: none;
        }

        .loading-logo {
            width: 80px;
            height: 80px;
            margin-bottom: 24px;
            animation: float 2s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .loader {
            width: 48px;
            height: 48px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top-color: #00d9ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 20px;
            color: #666;
            font-size: 0.85rem;
        }

        .mode-selector {
            display: flex;
            gap: 6px;
            margin-top: 12px;
        }

        .mode-btn {
            padding: 10px 16px;
            font-size: 0.75rem;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            color: #888;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
        }

        .mode-btn:hover {
            background: rgba(255,255,255,0.1);
            color: #fff;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #00d9ff, #00ff88);
            color: #000;
            border-color: transparent;
            font-weight: 600;
        }

        .trigger-flash {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            pointer-events: none;
            z-index: 200;
            opacity: 0;
            transition: opacity 0.1s;
        }

        .trigger-flash.show {
            opacity: 1;
            animation: flashPop 0.3s ease-out;
        }

        @keyframes flashPop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
        }

        .recording-indicator {
            position: fixed;
            top: 24px;
            right: 280px;
            background: rgba(255, 0, 0, 0.9);
            padding: 10px 18px;
            border-radius: 24px;
            display: none;
            align-items: center;
            gap: 10px;
            z-index: 200;
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: 0 4px 20px rgba(255,0,0,0.3);
        }

        .recording-indicator.show {
            display: flex;
        }

        .recording-dot {
            width: 10px;
            height: 10px;
            background: #fff;
            border-radius: 50%;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Scrollbar styling */
        .status-panel::-webkit-scrollbar {
            width: 4px;
        }

        .status-panel::-webkit-scrollbar-track {
            background: transparent;
        }

        .status-panel::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div id="loadingScreen" class="loading-screen">
        <svg class="loading-logo" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <linearGradient id="loadGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#00d9ff"/>
                    <stop offset="50%" style="stop-color:#00ff88"/>
                    <stop offset="100%" style="stop-color:#ff6b6b"/>
                </linearGradient>
            </defs>
            <circle cx="50" cy="50" r="45" stroke="url(#loadGrad)" stroke-width="3" fill="none" opacity="0.3"/>
            <circle cx="50" cy="50" r="35" stroke="url(#loadGrad)" stroke-width="2" fill="none" opacity="0.5"/>
            <circle cx="50" cy="50" r="25" stroke="url(#loadGrad)" stroke-width="2" fill="none" opacity="0.7"/>
            <circle cx="50" cy="50" r="8" fill="url(#loadGrad)"/>
            <path d="M50 20 L50 10 M50 80 L50 90 M20 50 L10 50 M80 50 L90 50" stroke="url(#loadGrad)" stroke-width="2" stroke-linecap="round"/>
        </svg>
        <div class="loader"></div>
        <p class="loading-text">Initializing Echo...</p>
    </div>

    <canvas id="mainCanvas"></canvas>

    <div id="overlay">
        <div class="logo-container">
            <svg class="logo-icon" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <linearGradient id="logoGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#00d9ff"/>
                        <stop offset="50%" style="stop-color:#00ff88"/>
                        <stop offset="100%" style="stop-color:#ff6b6b"/>
                    </linearGradient>
                </defs>
                <circle cx="50" cy="50" r="45" stroke="url(#logoGrad)" stroke-width="3" fill="none" opacity="0.3"/>
                <circle cx="50" cy="50" r="35" stroke="url(#logoGrad)" stroke-width="2" fill="none" opacity="0.5"/>
                <circle cx="50" cy="50" r="25" stroke="url(#logoGrad)" stroke-width="2" fill="none" opacity="0.7"/>
                <circle cx="50" cy="50" r="8" fill="url(#logoGrad)"/>
                <path d="M50 20 L50 10 M50 80 L50 90 M20 50 L10 50 M80 50 L90 50" stroke="url(#logoGrad)" stroke-width="2" stroke-linecap="round"/>
            </svg>
            <h1>Echo</h1>
        </div>
        <p class="subtitle">Your body is the instrument</p>
    </div>

    <div class="controls">
        <button id="startBtn" class="btn btn-start" disabled>
            <span>‚ñ∂</span> Start
        </button>
        <button id="recordBtn" class="btn btn-record" disabled>
            <span>‚óè</span> Record
        </button>
        <button id="playBtn" class="btn btn-play" disabled>
            <span>‚ñ∂</span> Play
        </button>
        <div class="mode-selector">
            <button class="mode-btn active" data-mode="all">All</button>
            <button class="mode-btn" data-mode="voice">Voice</button>
            <button class="mode-btn" data-mode="strings">Strings</button>
            <button class="mode-btn" data-mode="drums">Drums</button>
        </div>
    </div>

    <div class="recording-indicator" id="recordingIndicator">
        <div class="recording-dot"></div>
        <span id="recordingTime">0:00</span>
    </div>

    <div class="status-panel">
        <h3>Live</h3>
        <div class="instrument-status">
            <div class="instrument-row">
                <span class="instrument-icon">üé§</span>
                <span class="instrument-name">Voice</span>
                <div class="instrument-bar">
                    <div id="voiceLevel" class="instrument-fill voice-fill" style="width: 0%"></div>
                </div>
            </div>
            <div class="instrument-row">
                <span class="instrument-icon">üé∏</span>
                <span class="instrument-name">Strings</span>
                <div class="instrument-bar">
                    <div id="stringsLevel" class="instrument-fill strings-fill" style="width: 0%"></div>
                </div>
            </div>
            <div class="instrument-row">
                <span class="instrument-icon">ü•Å</span>
                <span class="instrument-name">Drums</span>
                <div class="instrument-bar">
                    <div id="drumsLevel" class="instrument-fill drums-fill" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <div class="settings-panel">
            <h4>Instruments</h4>
            <div class="setting-row">
                <label>Voice</label>
                <select id="voiceType">
                    <option value="warm">Warm Vocal</option>
                    <option value="choir">Choir Pad</option>
                    <option value="synth">Synth Lead</option>
                    <option value="theremin">Theremin</option>
                </select>
            </div>
            <div class="setting-row">
                <label>Strings</label>
                <select id="stringType">
                    <option value="harp">Harp</option>
                    <option value="guitar">Guitar</option>
                    <option value="piano">Piano</option>
                    <option value="bell">Bell/Chime</option>
                </select>
            </div>
            <div class="setting-row">
                <label>Drums</label>
                <select id="drumKit">
                    <option value="acoustic">Acoustic</option>
                    <option value="electronic">Electronic</option>
                    <option value="percussion">Percussion</option>
                </select>
            </div>
            <div class="setting-row">
                <label>Scale</label>
                <select id="scaleType">
                    <option value="major">C Major</option>
                    <option value="minor">A Minor</option>
                    <option value="pentatonic">Pentatonic</option>
                    <option value="chromatic">Chromatic</option>
                </select>
            </div>
        </div>
    </div>

    <div class="help-panel">
        <h3>How to Play</h3>
        <div class="help-item">
            <span class="help-icon">üòÆ</span>
            <span class="help-text"><strong>Open mouth</strong> to sing (eyebrows = pitch)</span>
        </div>
        <div class="help-item">
            <span class="help-icon">üñêÔ∏è</span>
            <span class="help-text"><strong>Tap fingers</strong> to pluck (5 notes)</span>
        </div>
        <div class="help-item">
            <span class="help-icon">‚ÜïÔ∏è</span>
            <span class="help-text"><strong>Hand height</strong> = octave</span>
        </div>
        <div class="help-item">
            <span class="help-icon">‚Üì</span>
            <span class="help-text"><strong>Nod down</strong> = kick</span>
        </div>
        <div class="help-item">
            <span class="help-icon">‚Üë</span>
            <span class="help-text"><strong>Nod up</strong> = snare</span>
        </div>
        <div class="help-item">
            <span class="help-icon">‚ÜîÔ∏è</span>
            <span class="help-text"><strong>Tilt head</strong> = hi-hat / tom</span>
        </div>
    </div>

    <div id="videoContainer">
        <video id="webcam" autoplay playsinline></video>
    </div>

    <div id="triggerFlash" class="trigger-flash"></div>

    <!-- Tone.js for audio synthesis -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

    <!-- MediaPipe -->
    <script type="module">
        import {
            FilesetResolver,
            HandLandmarker,
            FaceLandmarker
        } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.15/vision_bundle.mjs";

        // ==================== CONFIGURATION ====================
        const CONFIG = {
            voice: {
                minFreq: 130.81,  // C3
                maxFreq: 523.25, // C5
                mouthThreshold: 0.18,
            },
            strings: {
                scales: {
                    major: ['C', 'D', 'E', 'G', 'A'],
                    minor: ['A', 'C', 'D', 'E', 'G'],
                    pentatonic: ['C', 'D', 'E', 'G', 'A'],
                    chromatic: ['C', 'C#', 'D', 'D#', 'E']
                },
                // Improved finger detection - uses relative distance
                fingerCurlThreshold: 0.04,  // How much tip must be below PIP joint
                fingerCooldown: 80,         // ms between same finger triggers
                octaveRange: [3, 6],
            },
            drums: {
                nodThreshold: 0.012,
                tiltThreshold: 0.018,
                cooldown: 100,
            },
            particles: {
                maxParticles: 1500,
            }
        };

        const NOTE_FREQS = {
            'C': 261.63, 'C#': 277.18, 'D': 293.66, 'D#': 311.13,
            'E': 329.63, 'F': 349.23, 'F#': 369.99, 'G': 392.00,
            'G#': 415.30, 'A': 440.00, 'A#': 466.16, 'B': 493.88
        };

        // ==================== STATE ====================
        const state = {
            isRunning: false,
            mode: 'all',
            voice: { active: false, level: 0 },
            strings: {
                level: 0,
                // Track each finger independently with smoothing
                fingerStates: [
                    { curled: false, lastTrigger: 0, smoothed: 0 },
                    { curled: false, lastTrigger: 0, smoothed: 0 },
                    { curled: false, lastTrigger: 0, smoothed: 0 },
                    { curled: false, lastTrigger: 0, smoothed: 0 },
                    { curled: false, lastTrigger: 0, smoothed: 0 }
                ]
            },
            drums: { level: 0, lastTrigger: {}, prevHead: null, smoothedHead: null },
            particles: [],
            isRecording: false,
            isPlaying: false,
            recordedEvents: [],
            recordStartTime: 0,
            playbackTimeout: null,
            currentScale: 'major',
            voiceType: 'warm',
            stringType: 'harp',
            drumKit: 'acoustic'
        };

        // ==================== DOM ELEMENTS ====================
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const video = document.getElementById('webcam');
        const startBtn = document.getElementById('startBtn');
        const recordBtn = document.getElementById('recordBtn');
        const playBtn = document.getElementById('playBtn');
        const loadingScreen = document.getElementById('loadingScreen');
        const triggerFlash = document.getElementById('triggerFlash');
        const voiceLevelEl = document.getElementById('voiceLevel');
        const stringsLevelEl = document.getElementById('stringsLevel');
        const drumsLevelEl = document.getElementById('drumsLevel');
        const recordingIndicator = document.getElementById('recordingIndicator');
        const recordingTimeEl = document.getElementById('recordingTime');

        const voiceTypeSelect = document.getElementById('voiceType');
        const stringTypeSelect = document.getElementById('stringType');
        const drumKitSelect = document.getElementById('drumKit');
        const scaleTypeSelect = document.getElementById('scaleType');

        // ==================== AUDIO ENGINE ====================
        let audioEngine = null;

        function initAudio() {
            const masterGain = new Tone.Gain(0.7).toDestination();
            const reverb = new Tone.Reverb({ decay: 2.5, wet: 0.3 }).connect(masterGain);
            const delay = new Tone.FeedbackDelay({ delayTime: '8n', feedback: 0.15, wet: 0.1 }).connect(reverb);

            const voiceSynths = {
                warm: createVoiceSynth('warm', delay),
                choir: createVoiceSynth('choir', delay),
                synth: createVoiceSynth('synth', delay),
                theremin: createVoiceSynth('theremin', delay)
            };

            const stringSynths = {
                harp: createStringSynth('harp', delay),
                guitar: createStringSynth('guitar', delay),
                piano: createStringSynth('piano', delay),
                bell: createStringSynth('bell', delay)
            };

            const drumKits = {
                acoustic: createDrumKit('acoustic', masterGain, reverb),
                electronic: createDrumKit('electronic', masterGain, reverb),
                percussion: createDrumKit('percussion', masterGain, reverb)
            };

            audioEngine = {
                voiceSynths,
                stringSynths,
                drumKits,
                masterGain,
                voice: {
                    isPlaying: false,
                    currentSynth: null,
                    play(freq, volume, type) {
                        const synth = voiceSynths[type];
                        if (!this.isPlaying || this.currentSynth !== synth) {
                            if (this.isPlaying && this.currentSynth) {
                                this.currentSynth.synth.triggerRelease();
                            }
                            synth.synth.triggerAttack(freq);
                            this.isPlaying = true;
                            this.currentSynth = synth;
                        }
                        synth.synth.frequency.rampTo(freq, 0.1);
                        synth.synth.volume.rampTo(Tone.gainToDb(volume), 0.1);
                    },
                    stop() {
                        if (this.isPlaying && this.currentSynth) {
                            this.currentSynth.synth.triggerRelease();
                            this.isPlaying = false;
                        }
                    }
                },
                strings: {
                    pluck(note, octave, velocity, type) {
                        const synth = stringSynths[type];
                        synth.synth.triggerAttackRelease(note + octave, '4n', undefined, velocity);
                    }
                },
                drums: {
                    trigger(drum, velocity, kit) {
                        const drumKit = drumKits[kit];
                        if (drumKit[drum]) drumKit[drum].trigger(velocity);
                    }
                }
            };

            console.log('Echo audio engine ready');
        }

        function createVoiceSynth(type, output) {
            let synth;
            switch(type) {
                case 'warm':
                    synth = new Tone.MonoSynth({
                        oscillator: { type: 'sawtooth' },
                        filter: { type: 'lowpass', frequency: 1000, Q: 2 },
                        envelope: { attack: 0.1, decay: 0.2, sustain: 0.8, release: 0.5 },
                        filterEnvelope: { attack: 0.1, decay: 0.2, sustain: 0.5, release: 0.5, baseFrequency: 200, octaves: 2 }
                    });
                    break;
                case 'choir':
                    synth = new Tone.MonoSynth({
                        oscillator: { type: 'sine' },
                        filter: { type: 'lowpass', frequency: 800 },
                        envelope: { attack: 0.3, decay: 0.3, sustain: 0.9, release: 0.8 }
                    });
                    break;
                case 'synth':
                    synth = new Tone.MonoSynth({
                        oscillator: { type: 'square' },
                        filter: { type: 'lowpass', frequency: 2000, Q: 5 },
                        envelope: { attack: 0.01, decay: 0.1, sustain: 0.7, release: 0.3 },
                        filterEnvelope: { attack: 0.05, decay: 0.2, sustain: 0.3, release: 0.3, baseFrequency: 500, octaves: 3 }
                    });
                    break;
                case 'theremin':
                    synth = new Tone.MonoSynth({
                        oscillator: { type: 'sine' },
                        envelope: { attack: 0.05, decay: 0.1, sustain: 1, release: 0.5 }
                    });
                    break;
            }
            const vibrato = new Tone.Vibrato({ frequency: 5, depth: 0.1 }).connect(output);
            synth.connect(vibrato);
            return { synth, vibrato };
        }

        function createStringSynth(type, output) {
            let synth;
            switch(type) {
                case 'harp':
                    synth = new Tone.PolySynth(Tone.Synth, {
                        oscillator: { type: 'triangle' },
                        envelope: { attack: 0.005, decay: 0.8, sustain: 0.1, release: 1.5 }
                    });
                    break;
                case 'guitar':
                    synth = new Tone.PolySynth(Tone.Synth, {
                        oscillator: { type: 'sawtooth' },
                        envelope: { attack: 0.002, decay: 0.3, sustain: 0.2, release: 0.8 }
                    });
                    break;
                case 'piano':
                    synth = new Tone.PolySynth(Tone.Synth, {
                        oscillator: { type: 'triangle' },
                        envelope: { attack: 0.001, decay: 1, sustain: 0.3, release: 1 }
                    });
                    break;
                case 'bell':
                    synth = new Tone.PolySynth(Tone.Synth, {
                        oscillator: { type: 'sine' },
                        envelope: { attack: 0.001, decay: 2, sustain: 0, release: 2 }
                    });
                    break;
            }
            const filter = new Tone.Filter({ type: 'lowpass', frequency: 3000 }).connect(output);
            synth.connect(filter);
            return { synth, filter };
        }

        function createDrumKit(type, masterGain, reverb) {
            const kit = {};
            switch(type) {
                case 'acoustic':
                    kit.kick = {
                        synth: new Tone.MembraneSynth({
                            pitchDecay: 0.05, octaves: 6,
                            envelope: { attack: 0.001, decay: 0.4, sustain: 0, release: 0.4 }
                        }).connect(masterGain),
                        trigger(vel) { this.synth.triggerAttackRelease('C1', '8n', undefined, vel); }
                    };
                    kit.snare = {
                        noise: new Tone.NoiseSynth({
                            noise: { type: 'white' },
                            envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.15 }
                        }).connect(masterGain),
                        body: new Tone.MembraneSynth({
                            pitchDecay: 0.01, octaves: 4,
                            envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }
                        }).connect(masterGain),
                        trigger(vel) {
                            this.noise.triggerAttackRelease('8n', undefined, vel * 0.6);
                            this.body.triggerAttackRelease('G3', '16n', undefined, vel);
                        }
                    };
                    kit.hihat = {
                        synth: new Tone.MetalSynth({
                            frequency: 400, envelope: { attack: 0.001, decay: 0.08, sustain: 0, release: 0.08 },
                            harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5
                        }).connect(new Tone.Gain(0.25).connect(masterGain)),
                        trigger(vel) { this.synth.triggerAttackRelease('32n', undefined, vel); }
                    };
                    kit.tom = {
                        synth: new Tone.MembraneSynth({
                            pitchDecay: 0.08, octaves: 4,
                            envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.3 }
                        }).connect(masterGain),
                        trigger(vel) { this.synth.triggerAttackRelease('G2', '8n', undefined, vel); }
                    };
                    break;
                case 'electronic':
                    kit.kick = {
                        synth: new Tone.MembraneSynth({
                            pitchDecay: 0.02, octaves: 8,
                            envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.2 }
                        }).connect(masterGain),
                        trigger(vel) { this.synth.triggerAttackRelease('C1', '8n', undefined, vel); }
                    };
                    kit.snare = {
                        noise: new Tone.NoiseSynth({
                            noise: { type: 'pink' },
                            envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }
                        }).connect(masterGain),
                        trigger(vel) { this.noise.triggerAttackRelease('16n', undefined, vel); }
                    };
                    kit.hihat = {
                        synth: new Tone.NoiseSynth({
                            noise: { type: 'white' },
                            envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.05 }
                        }).connect(new Tone.Gain(0.3).connect(masterGain)),
                        trigger(vel) { this.synth.triggerAttackRelease('32n', undefined, vel); }
                    };
                    kit.tom = {
                        synth: new Tone.Synth({
                            oscillator: { type: 'sine' },
                            envelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.2 }
                        }).connect(masterGain),
                        trigger(vel) { this.synth.triggerAttackRelease('E2', '8n', undefined, vel); }
                    };
                    break;
                case 'percussion':
                    kit.kick = {
                        synth: new Tone.MembraneSynth({
                            pitchDecay: 0.1, octaves: 3,
                            envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.5 }
                        }).connect(reverb),
                        trigger(vel) { this.synth.triggerAttackRelease('D2', '4n', undefined, vel); }
                    };
                    kit.snare = {
                        synth: new Tone.MembraneSynth({
                            pitchDecay: 0.03, octaves: 2,
                            envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.2 }
                        }).connect(reverb),
                        trigger(vel) { this.synth.triggerAttackRelease('A3', '8n', undefined, vel); }
                    };
                    kit.hihat = {
                        synth: new Tone.MetalSynth({
                            frequency: 800, envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.15 },
                            harmonicity: 3, modulationIndex: 20, octaves: 1
                        }).connect(new Tone.Gain(0.2).connect(reverb)),
                        trigger(vel) { this.synth.triggerAttackRelease('16n', undefined, vel); }
                    };
                    kit.tom = {
                        synth: new Tone.MembraneSynth({
                            pitchDecay: 0.15, octaves: 2,
                            envelope: { attack: 0.01, decay: 0.4, sustain: 0, release: 0.4 }
                        }).connect(reverb),
                        trigger(vel) { this.synth.triggerAttackRelease('C3', '4n', undefined, vel); }
                    };
                    break;
            }
            return kit;
        }

        // ==================== MEDIAPIPE SETUP ====================
        let handLandmarker, faceLandmarker;

        async function initMediaPipe() {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.15/wasm"
            );

            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task',
                    delegate: 'GPU'
                },
                runningMode: 'VIDEO',
                numHands: 2,
                minHandDetectionConfidence: 0.7,
                minHandPresenceConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',
                    delegate: 'GPU'
                },
                runningMode: 'VIDEO',
                numFaces: 1,
                outputFaceBlendshapes: true,
                minFaceDetectionConfidence: 0.7,
                minFacePresenceConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            console.log('MediaPipe initialized');
        }

        // ==================== CAMERA SETUP ====================
        async function initCamera() {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: 1280, height: 720, facingMode: 'user', frameRate: { ideal: 30 } }
            });
            video.srcObject = stream;
            await video.play();

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // ==================== PARTICLE SYSTEM ====================
        class Particle {
            constructor(x, y, color, type) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.life = 1;
                this.decay = 0.015 + Math.random() * 0.02;
                this.size = 3 + Math.random() * 5;
                this.color = color;
                this.type = type;

                if (type === 'drums') {
                    this.vx *= 3;
                    this.vy *= 3;
                    this.size *= 2;
                    this.decay *= 2;
                }
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;

                if (this.type === 'voice') {
                    this.vy -= 0.1;
                    this.vx *= 0.98;
                } else if (this.type === 'strings') {
                    this.vy += 0.05;
                    this.vx *= 0.99;
                } else {
                    this.vx *= 0.95;
                    this.vy *= 0.95;
                }
            }

            draw(ctx) {
                const radius = Math.max(0, this.size * this.life);
                if (radius <= 0) return;
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color.replace(')', `, ${Math.max(0, this.life)})`).replace('rgb', 'rgba');
                ctx.fill();
            }
        }

        function emitParticles(x, y, color, type, count = 5) {
            for (let i = 0; i < count; i++) {
                if (state.particles.length < CONFIG.particles.maxParticles) {
                    state.particles.push(new Particle(x, y, color, type));
                }
            }
        }

        // ==================== RECORDING ====================
        function recordEvent(type, data) {
            if (state.isRecording) {
                state.recordedEvents.push({ timestamp: Date.now() - state.recordStartTime, type, data });
            }
        }

        function startRecording() {
            state.recordedEvents = [];
            state.recordStartTime = Date.now();
            state.isRecording = true;
            recordBtn.classList.add('recording');
            recordBtn.innerHTML = '<span>‚ñ†</span> Stop';
            recordingIndicator.classList.add('show');
            updateRecordingTime();
        }

        function stopRecording() {
            state.isRecording = false;
            recordBtn.classList.remove('recording');
            recordBtn.innerHTML = '<span>‚óè</span> Record';
            recordingIndicator.classList.remove('show');
            if (state.recordedEvents.length > 0) playBtn.disabled = false;
        }

        function updateRecordingTime() {
            if (!state.isRecording) return;
            const elapsed = Math.floor((Date.now() - state.recordStartTime) / 1000);
            recordingTimeEl.textContent = `${Math.floor(elapsed / 60)}:${(elapsed % 60).toString().padStart(2, '0')}`;
            requestAnimationFrame(updateRecordingTime);
        }

        function playRecording() {
            if (state.recordedEvents.length === 0 || state.isPlaying) return;
            state.isPlaying = true;
            playBtn.innerHTML = '<span>‚ñ†</span> Stop';

            let eventIndex = 0;
            const startTime = Date.now();

            function playNextEvent() {
                if (!state.isPlaying || eventIndex >= state.recordedEvents.length) {
                    stopPlayback();
                    return;
                }
                const event = state.recordedEvents[eventIndex];
                if (Date.now() - startTime >= event.timestamp) {
                    triggerRecordedEvent(event);
                    eventIndex++;
                }
                state.playbackTimeout = requestAnimationFrame(playNextEvent);
            }
            playNextEvent();
        }

        function stopPlayback() {
            state.isPlaying = false;
            playBtn.innerHTML = '<span>‚ñ∂</span> Play';
            if (state.playbackTimeout) cancelAnimationFrame(state.playbackTimeout);
        }

        function triggerRecordedEvent(event) {
            switch(event.type) {
                case 'voice':
                    audioEngine.voice.play(event.data.freq, event.data.volume, state.voiceType);
                    break;
                case 'voice_stop':
                    audioEngine.voice.stop();
                    break;
                case 'string':
                    audioEngine.strings.pluck(event.data.note, event.data.octave, event.data.velocity, state.stringType);
                    emitParticles(event.data.x, event.data.y, event.data.color, 'strings', 10);
                    break;
                case 'drum':
                    audioEngine.drums.trigger(event.data.drum, event.data.velocity, state.drumKit);
                    emitParticles(canvas.width / 2, canvas.height / 2, event.data.color, 'drums', 15);
                    showTrigger(event.data.emoji);
                    break;
            }
        }

        // ==================== HELPERS ====================
        function getLandmarkPos(landmark) {
            return {
                x: (1 - landmark.x) * canvas.width,
                y: landmark.y * canvas.height,
                z: landmark.z
            };
        }

        function mapRange(value, inMin, inMax, outMin, outMax) {
            return Math.max(outMin, Math.min(outMax, (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin));
        }

        function showTrigger(emoji) {
            triggerFlash.textContent = emoji;
            triggerFlash.classList.add('show');
            setTimeout(() => triggerFlash.classList.remove('show'), 300);
        }

        // Exponential moving average for smoothing
        function smooth(current, target, factor = 0.3) {
            return current + (target - current) * factor;
        }

        // ==================== INSTRUMENT PROCESSORS ====================

        function processVoice(faceLandmarks, blendshapes) {
            if (!faceLandmarks || state.mode === 'strings' || state.mode === 'drums') {
                if (state.voice.active) {
                    audioEngine?.voice.stop();
                    recordEvent('voice_stop', {});
                }
                state.voice.active = false;
                state.voice.level = 0;
                return;
            }

            let mouthOpen = 0;
            let browUp = 0;

            if (blendshapes && blendshapes.length > 0) {
                const shapes = blendshapes[0].categories;
                for (const shape of shapes) {
                    if (shape.categoryName === 'jawOpen') mouthOpen = shape.score;
                    if (shape.categoryName === 'browOuterUpLeft' || shape.categoryName === 'browOuterUpRight') {
                        browUp = Math.max(browUp, shape.score);
                    }
                }
            }

            state.voice.level = mouthOpen;

            if (mouthOpen > CONFIG.voice.mouthThreshold) {
                state.voice.active = true;
                const pitchMod = mapRange(browUp, 0, 0.7, 0, 1);
                const freq = CONFIG.voice.minFreq + (CONFIG.voice.maxFreq - CONFIG.voice.minFreq) * pitchMod;
                const volume = mapRange(mouthOpen, CONFIG.voice.mouthThreshold, 0.7, 0.3, 1);

                audioEngine.voice.play(freq, volume, state.voiceType);
                recordEvent('voice', { freq, volume });

                const pos = getLandmarkPos(faceLandmarks[13]);
                const hue = mapRange(freq, CONFIG.voice.minFreq, CONFIG.voice.maxFreq, 0, 60);
                emitParticles(pos.x, pos.y, `rgb(${255}, ${Math.floor(100 + hue * 2)}, ${50})`, 'voice', Math.floor(volume * 3));
            } else {
                if (state.voice.active) {
                    audioEngine?.voice.stop();
                    recordEvent('voice_stop', {});
                }
                state.voice.active = false;
            }
        }

        // Improved finger detection - like playing piano
        function processStrings(handResults) {
            if (state.mode === 'voice' || state.mode === 'drums') {
                state.strings.level = 0;
                return;
            }

            if (!handResults || handResults.length === 0) {
                state.strings.level = 0;
                // Reset all finger states when no hand detected
                state.strings.fingerStates.forEach(f => { f.curled = false; f.smoothed = 0; });
                return;
            }

            const scale = CONFIG.strings.scales[state.currentScale];
            const now = Date.now();

            handResults.forEach((hand) => {
                const wrist = hand[0];
                const handHeight = 1 - wrist.y;
                const octave = Math.floor(mapRange(handHeight, 0.2, 0.8, CONFIG.strings.octaveRange[0], CONFIG.strings.octaveRange[1]));

                // Finger landmark indices: tip, DIP, PIP, MCP
                const fingers = [
                    { tip: 4, pip: 3, mcp: 2, name: 'thumb' },
                    { tip: 8, pip: 7, mcp: 5, name: 'index' },
                    { tip: 12, pip: 11, mcp: 9, name: 'middle' },
                    { tip: 16, pip: 15, mcp: 13, name: 'ring' },
                    { tip: 20, pip: 19, mcp: 17, name: 'pinky' }
                ];

                fingers.forEach((finger, idx) => {
                    const tip = hand[finger.tip];
                    const pip = hand[finger.pip];
                    const mcp = hand[finger.mcp];

                    // Calculate curl amount - how much tip is below PIP joint
                    // For thumb, compare against MCP
                    let curlAmount;
                    if (idx === 0) {
                        // Thumb uses different detection - tip X relative to MCP X
                        curlAmount = Math.abs(tip.x - mcp.x);
                        const thumbCurled = curlAmount < 0.04;

                        // Smooth the detection
                        state.strings.fingerStates[idx].smoothed = smooth(
                            state.strings.fingerStates[idx].smoothed,
                            thumbCurled ? 1 : 0,
                            0.4
                        );
                    } else {
                        // Other fingers - tip Y relative to PIP Y
                        curlAmount = tip.y - pip.y;

                        // Smooth the curl detection
                        state.strings.fingerStates[idx].smoothed = smooth(
                            state.strings.fingerStates[idx].smoothed,
                            curlAmount,
                            0.4
                        );
                    }

                    const fingerState = state.strings.fingerStates[idx];
                    const isCurled = idx === 0
                        ? fingerState.smoothed > 0.5  // Thumb threshold
                        : fingerState.smoothed > CONFIG.strings.fingerCurlThreshold;

                    // Detect transition from extended to curled
                    if (isCurled && !fingerState.curled && now - fingerState.lastTrigger > CONFIG.strings.fingerCooldown) {
                        const note = scale[idx % scale.length];
                        const velocity = 0.7 + Math.random() * 0.3;

                        audioEngine.strings.pluck(note, octave, velocity, state.stringType);

                        const tipPos = getLandmarkPos(tip);
                        const colors = ['rgb(100, 180, 255)', 'rgb(150, 100, 255)', 'rgb(255, 100, 200)', 'rgb(100, 255, 180)', 'rgb(255, 200, 100)'];
                        emitParticles(tipPos.x, tipPos.y, colors[idx], 'strings', 12);

                        state.strings.level = 1;
                        fingerState.lastTrigger = now;

                        recordEvent('string', { note, octave, velocity, x: tipPos.x, y: tipPos.y, color: colors[idx] });
                    }

                    fingerState.curled = isCurled;
                });
            });

            state.strings.level *= 0.9;
        }

        function processDrums(faceLandmarks, blendshapes) {
            if (state.mode === 'voice' || state.mode === 'strings') {
                state.drums.level = 0;
                return;
            }

            if (!faceLandmarks) {
                state.drums.level = 0;
                state.drums.prevHead = null;
                state.drums.smoothedHead = null;
                return;
            }

            const now = Date.now();
            const noseTip = faceLandmarks[1];
            const forehead = faceLandmarks[10];
            const leftCheek = faceLandmarks[234];
            const rightCheek = faceLandmarks[454];

            const headY = (noseTip.y + forehead.y) / 2;
            const headX = (leftCheek.x + rightCheek.x) / 2;
            const headTilt = leftCheek.y - rightCheek.y;

            // Smooth head position
            if (!state.drums.smoothedHead) {
                state.drums.smoothedHead = { y: headY, x: headX, tilt: headTilt };
            } else {
                state.drums.smoothedHead.y = smooth(state.drums.smoothedHead.y, headY, 0.5);
                state.drums.smoothedHead.x = smooth(state.drums.smoothedHead.x, headX, 0.5);
                state.drums.smoothedHead.tilt = smooth(state.drums.smoothedHead.tilt, headTilt, 0.5);
            }

            if (state.drums.prevHead) {
                const velY = state.drums.smoothedHead.y - state.drums.prevHead.y;
                const tiltChange = state.drums.smoothedHead.tilt - state.drums.prevHead.tilt;

                // NOD DOWN = KICK
                if (velY > CONFIG.drums.nodThreshold &&
                    (!state.drums.lastTrigger.kick || now - state.drums.lastTrigger.kick > CONFIG.drums.cooldown)) {
                    const velocity = mapRange(Math.abs(velY), CONFIG.drums.nodThreshold, 0.04, 0.5, 1);
                    audioEngine.drums.trigger('kick', velocity, state.drumKit);
                    emitParticles(canvas.width / 2, canvas.height / 2 + 100, 'rgb(100, 255, 100)', 'drums', 20);
                    showTrigger('‚¨á');
                    state.drums.lastTrigger.kick = now;
                    state.drums.level = 1;
                    recordEvent('drum', { drum: 'kick', velocity, color: 'rgb(100, 255, 100)', emoji: '‚¨á' });
                }

                // NOD UP = SNARE
                if (velY < -CONFIG.drums.nodThreshold &&
                    (!state.drums.lastTrigger.snare || now - state.drums.lastTrigger.snare > CONFIG.drums.cooldown)) {
                    const velocity = mapRange(Math.abs(velY), CONFIG.drums.nodThreshold, 0.04, 0.5, 1);
                    audioEngine.drums.trigger('snare', velocity, state.drumKit);
                    emitParticles(canvas.width / 2, canvas.height / 2 - 50, 'rgb(255, 255, 150)', 'drums', 20);
                    showTrigger('‚¨Ü');
                    state.drums.lastTrigger.snare = now;
                    state.drums.level = 1;
                    recordEvent('drum', { drum: 'snare', velocity, color: 'rgb(255, 255, 150)', emoji: '‚¨Ü' });
                }

                // TILT LEFT = HI-HAT
                if (tiltChange > CONFIG.drums.tiltThreshold &&
                    (!state.drums.lastTrigger.hihat || now - state.drums.lastTrigger.hihat > CONFIG.drums.cooldown / 2)) {
                    audioEngine.drums.trigger('hihat', 0.6, state.drumKit);
                    emitParticles(canvas.width / 2 - 100, canvas.height / 2, 'rgb(255, 255, 200)', 'drums', 10);
                    state.drums.lastTrigger.hihat = now;
                    state.drums.level = 0.7;
                    recordEvent('drum', { drum: 'hihat', velocity: 0.6, color: 'rgb(255, 255, 200)', emoji: '‚óÄ' });
                }

                // TILT RIGHT = TOM
                if (tiltChange < -CONFIG.drums.tiltThreshold &&
                    (!state.drums.lastTrigger.tom || now - state.drums.lastTrigger.tom > CONFIG.drums.cooldown)) {
                    audioEngine.drums.trigger('tom', 0.8, state.drumKit);
                    emitParticles(canvas.width / 2 + 100, canvas.height / 2, 'rgb(150, 255, 100)', 'drums', 15);
                    state.drums.lastTrigger.tom = now;
                    state.drums.level = 0.8;
                    recordEvent('drum', { drum: 'tom', velocity: 0.8, color: 'rgb(150, 255, 100)', emoji: '‚ñ∂' });
                }
            }

            state.drums.prevHead = { y: state.drums.smoothedHead.y, x: state.drums.smoothedHead.x, tilt: state.drums.smoothedHead.tilt };
            state.drums.level *= 0.9;
        }

        // ==================== VISUAL FEEDBACK ====================
        function drawHands(hands) {
            if (!hands || hands.length === 0) return;

            const scale = CONFIG.strings.scales[state.currentScale];

            hands.forEach(hand => {
                const connections = [
                    [0, 1], [1, 2], [2, 3], [3, 4],
                    [0, 5], [5, 6], [6, 7], [7, 8],
                    [0, 9], [9, 10], [10, 11], [11, 12],
                    [0, 13], [13, 14], [14, 15], [15, 16],
                    [0, 17], [17, 18], [18, 19], [19, 20],
                    [5, 9], [9, 13], [13, 17]
                ];

                ctx.strokeStyle = 'rgba(100, 200, 255, 0.4)';
                ctx.lineWidth = 2;

                connections.forEach(([i, j]) => {
                    const p1 = getLandmarkPos(hand[i]);
                    const p2 = getLandmarkPos(hand[j]);
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                });

                const fingerTips = [4, 8, 12, 16, 20];
                const colors = ['#ff6b6b', '#ffd93d', '#6bcb77', '#4d96ff', '#9b59b6'];

                fingerTips.forEach((idx, fingerIdx) => {
                    const pos = getLandmarkPos(hand[idx]);
                    const fingerState = state.strings.fingerStates[fingerIdx];
                    const isActive = fingerState.curled;

                    const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, isActive ? 35 : 25);
                    gradient.addColorStop(0, isActive ? '#fff' : colors[fingerIdx]);
                    gradient.addColorStop(1, 'transparent');

                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, isActive ? 35 : 25, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();

                    ctx.fillStyle = isActive ? '#000' : '#fff';
                    ctx.font = 'bold 14px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(scale[fingerIdx], pos.x, pos.y + 5);
                });
            });
        }

        function drawFace(face) {
            if (!face || face.length === 0) return;

            const noseTip = getLandmarkPos(face[1]);

            ctx.strokeStyle = 'rgba(255, 200, 100, 0.2)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(noseTip.x, noseTip.y, 40, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.font = '16px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('‚¨Ü', noseTip.x, noseTip.y - 55);
            ctx.fillText('‚¨á', noseTip.x, noseTip.y + 70);
            ctx.fillText('‚óÄ', noseTip.x - 65, noseTip.y + 5);
            ctx.fillText('‚ñ∂', noseTip.x + 65, noseTip.y + 5);
        }

        // ==================== MAIN LOOP ====================
        async function processFrame(timestamp) {
            if (!state.isRunning) return;

            ctx.fillStyle = 'rgba(10, 10, 15, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const handResult = handLandmarker.detectForVideo(video, timestamp);
            const faceResult = faceLandmarker.detectForVideo(video, timestamp);

            processVoice(faceResult.faceLandmarks?.[0], faceResult.faceBlendshapes);
            processStrings(handResult.landmarks);
            processDrums(faceResult.faceLandmarks?.[0], faceResult.faceBlendshapes);

            if (handResult.landmarks) drawHands(handResult.landmarks);
            if (faceResult.faceLandmarks?.[0]) drawFace(faceResult.faceLandmarks[0]);

            state.particles.forEach(p => p.update());
            state.particles = state.particles.filter(p => p.life > 0);
            state.particles.forEach(p => p.draw(ctx));

            voiceLevelEl.style.width = `${state.voice.level * 100}%`;
            stringsLevelEl.style.width = `${state.strings.level * 100}%`;
            drumsLevelEl.style.width = `${state.drums.level * 100}%`;

            requestAnimationFrame(processFrame);
        }

        // ==================== EVENT HANDLERS ====================
        startBtn.addEventListener('click', async () => {
            if (!state.isRunning) {
                await Tone.start();
                state.isRunning = true;
                startBtn.innerHTML = '<span>‚ñ†</span> Stop';
                recordBtn.disabled = false;
                requestAnimationFrame(processFrame);
            } else {
                state.isRunning = false;
                startBtn.innerHTML = '<span>‚ñ∂</span> Start';
                recordBtn.disabled = true;
                audioEngine.voice.stop();
                if (state.isRecording) stopRecording();
                if (state.isPlaying) stopPlayback();
            }
        });

        recordBtn.addEventListener('click', () => {
            if (state.isRecording) stopRecording();
            else startRecording();
        });

        playBtn.addEventListener('click', () => {
            if (state.isPlaying) stopPlayback();
            else playRecording();
        });

        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                state.mode = btn.dataset.mode;
                if (state.mode !== 'all' && state.mode !== 'voice') audioEngine?.voice.stop();
            });
        });

        voiceTypeSelect.addEventListener('change', (e) => { state.voiceType = e.target.value; });
        stringTypeSelect.addEventListener('change', (e) => { state.stringType = e.target.value; });
        drumKitSelect.addEventListener('change', (e) => { state.drumKit = e.target.value; });
        scaleTypeSelect.addEventListener('change', (e) => { state.currentScale = e.target.value; });

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // ==================== INITIALIZATION ====================
        async function init() {
            try {
                await initMediaPipe();
                await initCamera();
                initAudio();

                loadingScreen.classList.add('hidden');
                startBtn.disabled = false;

                console.log('Echo is ready!');
            } catch (error) {
                console.error('Initialization failed:', error);
                loadingScreen.querySelector('.loading-text').textContent =
                    'Failed to initialize. Please allow camera access and refresh.';
            }
        }

        // Register service worker for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').then(() => {
                console.log('Service Worker registered');
            }).catch(err => {
                console.log('Service Worker registration failed:', err);
            });
        }

        init();
    </script>
</body>
</html>
